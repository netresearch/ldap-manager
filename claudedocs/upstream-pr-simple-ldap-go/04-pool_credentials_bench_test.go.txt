// Performance Benchmarks for Credential-Aware Connection Pooling
// These benchmarks measure the performance impact of credential matching
// and validate that overhead is minimal (<5%).
//
// Benchmark Coverage:
// 1. Baseline - existing Get() method performance
// 2. Single-user with credentials - new method with one user
// 3. Multi-user sequential - rotating between different users
// 4. Multi-user concurrent - parallel operations with mixed credentials

package ldap

import (
	"sync"
	"testing"
	"time"
)

// BenchmarkPoolGet_Baseline establishes baseline performance for existing Get() method.
// This provides the reference point for measuring overhead of credential matching.
//
// Expected: ~10,000-50,000 ops/sec depending on hardware
func BenchmarkPoolGet_Baseline(b *testing.B) {
	config := &PoolConfig{
		MaxConnections:      10,
		MinConnections:      5,
		MaxIdleTime:         5 * time.Minute,
		MaxLifetime:         1 * time.Hour,
		HealthCheckInterval: 1 * time.Minute,
		GetTimeout:          5 * time.Second,
	}

	ldapConfig := Config{
		Host:     "ldap.example.com",
		Port:     389,
		BaseDN:   "dc=example,dc=com",
		UserDN:   "cn=admin,dc=example,dc=com",
		Password: "admin_password",
	}

	pool := NewConnectionPool(config, ldapConfig)
	defer pool.Close()

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			conn, err := pool.Get()
			if err != nil {
				b.Fatalf("Get() failed: %v", err)
			}
			pool.Put(conn)
		}
	})

	b.ReportMetric(float64(b.N)/b.Elapsed().Seconds(), "ops/sec")
}

// BenchmarkPoolGetWithCredentials_SingleUser measures performance with
// GetWithCredentials() using a single user credential.
//
// Expected: <5% overhead vs baseline (should be ~9,500-47,500 ops/sec)
// Overhead comes from credential matching logic
func BenchmarkPoolGetWithCredentials_SingleUser(b *testing.B) {
	config := &PoolConfig{
		MaxConnections:      10,
		MinConnections:      5,
		MaxIdleTime:         5 * time.Minute,
		MaxLifetime:         1 * time.Hour,
		HealthCheckInterval: 1 * time.Minute,
		GetTimeout:          5 * time.Second,
	}

	ldapConfig := Config{
		Host:     "ldap.example.com",
		Port:     389,
		BaseDN:   "dc=example,dc=com",
		UserDN:   "cn=admin,dc=example,dc=com",
		Password: "admin_password",
	}

	pool := NewConnectionPool(config, ldapConfig)
	defer pool.Close()

	userDN := "cn=user1,dc=example,dc=com"
	password := "password1"

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			conn, err := pool.GetWithCredentials(userDN, password)
			if err != nil {
				b.Fatalf("GetWithCredentials() failed: %v", err)
			}
			pool.Put(conn)
		}
	})

	b.ReportMetric(float64(b.N)/b.Elapsed().Seconds(), "ops/sec")

	stats := pool.GetStats()
	b.ReportMetric(float64(stats.AcquiredCount-stats.FailedCount)/float64(stats.AcquiredCount)*100, "reuse_%")
}

// BenchmarkPoolGetWithCredentials_MultiUserSequential measures performance
// when rotating through multiple user credentials sequentially.
//
// Expected: Similar to single-user, demonstrates efficient credential matching
// Reuse rate should be high (>80%) as same credentials are reused
func BenchmarkPoolGetWithCredentials_MultiUserSequential(b *testing.B) {
	config := &PoolConfig{
		MaxConnections:      10,
		MinConnections:      5,
		MaxIdleTime:         5 * time.Minute,
		MaxLifetime:         1 * time.Hour,
		HealthCheckInterval: 1 * time.Minute,
		GetTimeout:          5 * time.Second,
	}

	ldapConfig := Config{
		Host:     "ldap.example.com",
		Port:     389,
		BaseDN:   "dc=example,dc=com",
		UserDN:   "cn=admin,dc=example,dc=com",
		Password: "admin_password",
	}

	pool := NewConnectionPool(config, ldapConfig)
	defer pool.Close()

	// Define 3 users for rotation
	users := []struct {
		dn       string
		password string
	}{
		{"cn=user1,dc=example,dc=com", "password1"},
		{"cn=user2,dc=example,dc=com", "password2"},
		{"cn=user3,dc=example,dc=com", "password3"},
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		user := users[i%len(users)]
		conn, err := pool.GetWithCredentials(user.dn, user.password)
		if err != nil {
			b.Fatalf("GetWithCredentials() failed: %v", err)
		}
		pool.Put(conn)
	}

	b.ReportMetric(float64(b.N)/b.Elapsed().Seconds(), "ops/sec")

	stats := pool.GetStats()
	b.ReportMetric(float64(stats.TotalConnections), "total_conns")
	b.ReportMetric(float64(stats.AcquiredCount), "acquisitions")
}

// BenchmarkPoolGetWithCredentials_MultiUserConcurrent measures performance
// under realistic multi-user concurrent load with credential mixing.
//
// Expected: High throughput, demonstrates scalability
// This simulates a real web application scenario with multiple concurrent users
func BenchmarkPoolGetWithCredentials_MultiUserConcurrent(b *testing.B) {
	config := &PoolConfig{
		MaxConnections:      20,
		MinConnections:      5,
		MaxIdleTime:         5 * time.Minute,
		MaxLifetime:         1 * time.Hour,
		HealthCheckInterval: 1 * time.Minute,
		GetTimeout:          5 * time.Second,
	}

	ldapConfig := Config{
		Host:     "ldap.example.com",
		Port:     389,
		BaseDN:   "dc=example,dc=com",
		UserDN:   "cn=admin,dc=example,dc=com",
		Password: "admin_password",
	}

	pool := NewConnectionPool(config, ldapConfig)
	defer pool.Close()

	// Define 5 users for realistic web app simulation
	users := []struct {
		dn       string
		password string
	}{
		{"cn=user1,dc=example,dc=com", "password1"},
		{"cn=user2,dc=example,dc=com", "password2"},
		{"cn=user3,dc=example,dc=com", "password3"},
		{"cn=user4,dc=example,dc=com", "password4"},
		{"cn=user5,dc=example,dc=com", "password5"},
	}

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		i := 0
		for pb.Next() {
			user := users[i%len(users)]
			conn, err := pool.GetWithCredentials(user.dn, user.password)
			if err != nil {
				b.Fatalf("GetWithCredentials() failed: %v", err)
			}
			pool.Put(conn)
			i++
		}
	})

	b.ReportMetric(float64(b.N)/b.Elapsed().Seconds(), "ops/sec")

	stats := pool.GetStats()
	b.ReportMetric(float64(stats.TotalConnections), "total_conns")
	b.ReportMetric(float64(stats.FailedCount), "failures")
}

// BenchmarkConnectionReuseRate measures the efficiency of credential-based
// connection reuse by tracking hit/miss ratio.
//
// Expected: >80% reuse rate in typical scenarios
func BenchmarkConnectionReuseRate(b *testing.B) {
	config := &PoolConfig{
		MaxConnections:      10,
		MinConnections:      5,
		MaxIdleTime:         5 * time.Minute,
		MaxLifetime:         1 * time.Hour,
		HealthCheckInterval: 1 * time.Minute,
		GetTimeout:          5 * time.Second,
	}

	ldapConfig := Config{
		Host:     "ldap.example.com",
		Port:     389,
		BaseDN:   "dc=example,dc=com",
		UserDN:   "cn=admin,dc=example,dc=com",
		Password: "admin_password",
	}

	pool := NewConnectionPool(config, ldapConfig)
	defer pool.Close()

	users := []struct {
		dn       string
		password string
	}{
		{"cn=user1,dc=example,dc=com", "password1"},
		{"cn=user2,dc=example,dc=com", "password2"},
		{"cn=user3,dc=example,dc=com", "password3"},
	}

	// Track connection IDs to measure reuse
	type connKey struct {
		dn       string
		password string
	}
	seenConnections := make(map[connKey]map[string]bool)
	var mu sync.Mutex

	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		i := 0
		for pb.Next() {
			user := users[i%len(users)]
			conn, err := pool.GetWithCredentials(user.dn, user.password)
			if err != nil {
				b.Fatalf("GetWithCredentials() failed: %v", err)
			}

			// Track connection reuse
			key := connKey{dn: user.dn, password: user.password}
			connID := getConnectionIDFromConn(conn)

			mu.Lock()
			if seenConnections[key] == nil {
				seenConnections[key] = make(map[string]bool)
			}
			seenConnections[key][connID] = true
			mu.Unlock()

			pool.Put(conn)
			i++
		}
	})

	// Calculate reuse statistics
	totalUsers := len(users)
	totalUniqueConns := 0
	for _, conns := range seenConnections {
		totalUniqueConns += len(conns)
	}

	reuseEfficiency := (1.0 - float64(totalUniqueConns)/float64(totalUsers)) * 100
	b.ReportMetric(reuseEfficiency, "reuse_efficiency_%")
	b.ReportMetric(float64(totalUniqueConns), "unique_conns_per_user")
}

// BenchmarkCredentialMatchingOverhead isolates and measures the pure overhead
// of credential matching logic.
//
// Expected: <50ns per match operation
func BenchmarkCredentialMatchingOverhead(b *testing.B) {
	// Create mock pooled connection
	conn := &pooledConnection{
		credentials: &ConnectionCredentials{
			DN:       "cn=user1,dc=example,dc=com",
			Password: "password1",
		},
		isHealthy: true,
		createdAt: time.Now(),
		lastUsed:  time.Now(),
	}

	testCreds := &ConnectionCredentials{
		DN:       "cn=user1,dc=example,dc=com",
		Password: "password1",
	}

	config := &PoolConfig{
		MaxIdleTime: 5 * time.Minute,
		MaxLifetime: 1 * time.Hour,
	}

	pool := &ConnectionPool{
		config: config,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = pool.canReuseConnection(conn, testCreds)
	}

	nsPerOp := float64(b.Elapsed().Nanoseconds()) / float64(b.N)
	b.ReportMetric(nsPerOp, "ns/match")
}

// Helper function for benchmark connection tracking
func getConnectionIDFromConn(conn *ldap.Conn) string {
	// Placeholder: In real benchmarks, use connection pointer address
	return "conn_id_placeholder"
}

// Performance Summary and Interpretation:
//
// BASELINE PERFORMANCE:
// - BenchmarkPoolGet_Baseline: Establishes single-user baseline (~10-50k ops/sec)
//
// OVERHEAD MEASUREMENT:
// - BenchmarkPoolGetWithCredentials_SingleUser: Should be within 5% of baseline
// - BenchmarkCredentialMatchingOverhead: Raw matching cost (<50ns)
//
// MULTI-USER SCALABILITY:
// - BenchmarkPoolGetWithCredentials_MultiUserSequential: Demonstrates efficient rotation
// - BenchmarkPoolGetWithCredentials_MultiUserConcurrent: Real-world web app simulation
//
// EFFICIENCY METRICS:
// - BenchmarkConnectionReuseRate: Measures connection reuse efficiency (target: >80%)
//
// EXPECTED RESULTS:
// ✓ Overhead: <5% for credential-aware operations
// ✓ Reuse rate: >80% in typical multi-user scenarios
// ✓ Scalability: Linear throughput with concurrent users
// ✓ Baseline unchanged: Get() method performance unaffected